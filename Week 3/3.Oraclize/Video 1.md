# Oraclize

![[Week 3/3.Oraclize/attachments/index_3.mp4]]

[MUSIC] Recall that smart contract operates in a sandbox. It cannot call outside function or link to an external resource. So how do you get access to an external resource? By using a special smart contract called using oraclize. On completion of this lesson you will be able to explain a method for accessing external resources from a smart contract and illustrate the working of the oraclize smart contract. Why can't a smart contract access outside sources? Depending on the source code, it may affect the global consistency of the blockchain. The results of an operation on the blockchain has to be deterministic. These conditions limit the applicability of the smart contracts in many real world applications that may involve obtaining facts, data, and assets from external world sources. Moreover, the data has to be obtained at the time of execution and may not be available at the time of deployment of the contract. Let's look at some examples. How about the temperatures on Mount Kilimanjaro on a given day? It is a universal fact, but it has to be obtained in a given day from an authentic external weather source. As a second example, the stock market data, high and low price of a stock on a particular date, on NASDAQ market. The oraclize concept addresses this problem of fetching external data from a smart contract. What is oraclize? When you look up the meaning of oracle, Merriam-Webster's definition of oracle is, an authoritative or wise expression or answer. This definition very closely defines the rule of oraclized service in the smart contract dApp development. Oraclize is described as a data carrier between the web resources, APIs and the URLs, and the smart contract. Of course, oraclize is outside the blockchain protocol. However, it is a useful component of dApps that facilitate the availability of real world facts needed for the functioning of certain smart contracts. How do we use oraclize service? UsingOraclize is a smart contract that provides minimally a query function to access external sources. It not only fetches the data, but it also provides proofs and authentication about the sources if needed by calling the smart contract. The data requested is returned through a callback function since accessing the data and verification may take some time. We do not want the blockchain smart contract waiting on results. The following is a simple class diagram relating the smart contract, usingOraclize and an external data source. Now let's look at the sequence diagram to follow the timeline of execution of the various functions. With the smart contract, average winter temperature is deployed. It calls fetchData function. That in turn in-walks oraclize_query with the URL for the data source. Since it may take time to fetch the data, a call back function is provided so that it can invoked when the required data has been fetched. UsingOraclize accesses the external data source, authenticates and sends the data with the proof to the originating smart contract. In this case, AverageWinter Temperature. How do you use usingOraclize? First you import usingOraclize smart contract using the import statement. Then the contract AverageWinter Temperature inherits from usingOraclize. Contract AverageWinter Temperature is usingOraclize. Here, AverageWinter Temperature is inheriting usingOraclize and using its function to access external resources. As you observed, using usingOraclize smart contract is simple. Let the smart contract that you write inherit usingOraclize. It provides functions such as oraclize query, and lets you specify the data source address. You specify the external data source address in the query. Additionally, you may also have methods to verify the proof and authenticity of the data fetched. In summary, we learned about some best practices that can improve the basic design of dApp. First one is of the data structure level, memory versus storage. That helps to minimize the footprint of the Dapp on the blockchain. The second one is about event logging that is useful for asynchronous operation of Dapp clients, which improves efficiency. The third one is about accessing data and facts from external sources that is essential for many practical Dapps. These are just few of the many best practices exclusive to smart contracts and Dapps that'll improve your basic Dapp design.