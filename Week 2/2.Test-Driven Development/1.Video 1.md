# Test-Driven Development (Part 1) (Test Demo)

![[index_4.mp4]]
[MUSIC] Some of us who grew up with emergence of integrated chips and system on a chip, we know the importance of testing. Testing is an essential phase of hardware development. Once a chip is mass-produced, it's impossible to go and fix bugs, the design is hard-coded. To illustrate this, look up the Intel floating-point bug of 1994 that resulted in a massive recall of its Pentium chip. Also review the current Spectre and Meltdown bugs in the hardware chips that may result in security issues. Can you believe these bugs may require hardware redesign and replacement for almost all computing devices in the world using these chips? You can see why testing is a critical step to hardware design before a product is released. On the other hand, bug fixes on software systems are provided through weekly updates, as a routine. How about our smart contracts, the core logic of our Dapps? Smart contracts are like a hardware chip. Once deployed, they're final and cannot be updated, unless special provisions or escape hatches are built in. Recently, we heard of million-dollar heist in DAO hack and Parity wallet issues. These are indeed due to bugs in smart contract code. So testing is absolutely imperative for smart contracts. Upon completion of this lesson, you will be able to explain the importance of a test-driven development and test scripts in detail. Testing with ballot smart contract can be done by positive tests, making sure for a given valid input, it performs as expected. We'll test the complete ballot cycle of deploy, register, vote, winning proposal. And negative test, making sure it handles invalid inputs and situations appropriately. We'll code only two of the many negative tests possible. Usually, testers are written in the same language as the main application to be tested. You will write the tester itself as a smart contract and in Solidity language. There is a fine illustration of this in Truffle Pet Shop example. However, ballot contract uses address type data repeatedly for the chairperson and the voters. This causes a problem when another smart contract is used as a tester. So we'll use alternative language supported by Truffle, namely JavaScript, for writing our test. Truffle allows both languages, JavaScript and Solidity, we'll use JavaScript. Look at test.js, it has four positive tests and two negative tests. If we can open test.js using an editor, you can follow along. So far, we've used Truffle ID for initializing a template for Dapp development, populated this template with ballot.sol smart contract into the contracts folder. Compiled this smart contract and deployed it or migrated it to the test chain that Truffle ID provides. Now let's see how we can test it. In order to do that, we need to provide some test scripts in the test folder, we don't have anything there, as you can see. And luckily for us, we are provided the test script in the course resources. Let's copy this into the test folder. As you can see, the test script that we are provided is in JavaScript. You can also write test cases in Solidity, you have good examples of that in the literature. Let's see what test.js contains. I have it already open in the Atom editor. And the way we have designed it is that we have set up positive test cases and then couple of negative test cases. Later on, we can add any number of negative test cases. You can see that first line says that we need the Ballot.sol artifact. Then instant test instance of this ballot is created, and we make sure that it is deployed in the first test case. In the second test case, we want to make sure that good user registrations are going through. And we are registering three accounts and making sure that only the owner can register. So you can see that it's valid registrations are going through. And the third function is valid voting is going through. The fourth function is choosing the right winner. So the first four cases are completely testing the pipeline or the process of deploying, registering, voting, and winning functions. And the next two test cases are negative test cases where not the owner is trying to register an account, and an unregistered voter is trying to vote for that processes. So there are two test cases, there could be many more. And as you will see in the later demo, you will see many more test cases. This is going to be the template for your future applications testing that you may do. Okay, you need some basic JavaScript knowledge to do it. Let's go back here, and I have this available here, and I'm going to go back to the base directory. And of course, the command is truffle test. It compiled it, so we're just going to double test it. You can see that it through the test cases. And there are four test cases that are valid, we gave good inputs, and it did check it. And the next two are bad inputs, but it did indeed capture that and say that your Solidity smart contract did indeed capture these as bad inputs and did not execute the operation. So we passed the test, six tests passed. So this is the end of testing. We're going to add more testing in a future demo on ballot. On to the scenarios where the test failed.